// Generated by the protocol buffer compiler.  DO NOT EDIT!

#import "PasswordSpecifics.pb.h"

@implementation PasswordSpecificsRoot
static PBExtensionRegistry* extensionRegistry = nil;
+ (PBExtensionRegistry*) extensionRegistry {
  return extensionRegistry;
}

+ (void) initialize {
  if (self == [PasswordSpecificsRoot class]) {
    PBMutableExtensionRegistry* registry = [PBMutableExtensionRegistry registry];
    [self registerAllExtensions:registry];
    [EncryptionRoot registerAllExtensions:registry];
    extensionRegistry = [registry retain];
  }
}
+ (void) registerAllExtensions:(PBMutableExtensionRegistry*) registry {
}
@end

@interface PasswordSpecificsData ()
@property int32_t scheme;
@property (retain) NSString* signonRealm;
@property (retain) NSString* origin;
@property (retain) NSString* action;
@property (retain) NSString* usernameElement;
@property (retain) NSString* usernameValue;
@property (retain) NSString* passwordElement;
@property (retain) NSString* passwordValue;
@property BOOL sslValid;
@property BOOL preferred;
@property int64_t dateCreated;
@property BOOL blacklisted;
@end

@implementation PasswordSpecificsData

- (BOOL) hasScheme {
  return !!hasScheme_;
}
- (void) setHasScheme:(BOOL) value {
  hasScheme_ = !!value;
}
@synthesize scheme;
- (BOOL) hasSignonRealm {
  return !!hasSignonRealm_;
}
- (void) setHasSignonRealm:(BOOL) value {
  hasSignonRealm_ = !!value;
}
@synthesize signonRealm;
- (BOOL) hasOrigin {
  return !!hasOrigin_;
}
- (void) setHasOrigin:(BOOL) value {
  hasOrigin_ = !!value;
}
@synthesize origin;
- (BOOL) hasAction {
  return !!hasAction_;
}
- (void) setHasAction:(BOOL) value {
  hasAction_ = !!value;
}
@synthesize action;
- (BOOL) hasUsernameElement {
  return !!hasUsernameElement_;
}
- (void) setHasUsernameElement:(BOOL) value {
  hasUsernameElement_ = !!value;
}
@synthesize usernameElement;
- (BOOL) hasUsernameValue {
  return !!hasUsernameValue_;
}
- (void) setHasUsernameValue:(BOOL) value {
  hasUsernameValue_ = !!value;
}
@synthesize usernameValue;
- (BOOL) hasPasswordElement {
  return !!hasPasswordElement_;
}
- (void) setHasPasswordElement:(BOOL) value {
  hasPasswordElement_ = !!value;
}
@synthesize passwordElement;
- (BOOL) hasPasswordValue {
  return !!hasPasswordValue_;
}
- (void) setHasPasswordValue:(BOOL) value {
  hasPasswordValue_ = !!value;
}
@synthesize passwordValue;
- (BOOL) hasSslValid {
  return !!hasSslValid_;
}
- (void) setHasSslValid:(BOOL) value {
  hasSslValid_ = !!value;
}
- (BOOL) sslValid {
  return !!sslValid_;
}
- (void) setSslValid:(BOOL) value {
  sslValid_ = !!value;
}
- (BOOL) hasPreferred {
  return !!hasPreferred_;
}
- (void) setHasPreferred:(BOOL) value {
  hasPreferred_ = !!value;
}
- (BOOL) preferred {
  return !!preferred_;
}
- (void) setPreferred:(BOOL) value {
  preferred_ = !!value;
}
- (BOOL) hasDateCreated {
  return !!hasDateCreated_;
}
- (void) setHasDateCreated:(BOOL) value {
  hasDateCreated_ = !!value;
}
@synthesize dateCreated;
- (BOOL) hasBlacklisted {
  return !!hasBlacklisted_;
}
- (void) setHasBlacklisted:(BOOL) value {
  hasBlacklisted_ = !!value;
}
- (BOOL) blacklisted {
  return !!blacklisted_;
}
- (void) setBlacklisted:(BOOL) value {
  blacklisted_ = !!value;
}
- (void) dealloc {
  self.signonRealm = nil;
  self.origin = nil;
  self.action = nil;
  self.usernameElement = nil;
  self.usernameValue = nil;
  self.passwordElement = nil;
  self.passwordValue = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.scheme = 0;
    self.signonRealm = @"";
    self.origin = @"";
    self.action = @"";
    self.usernameElement = @"";
    self.usernameValue = @"";
    self.passwordElement = @"";
    self.passwordValue = @"";
    self.sslValid = NO;
    self.preferred = NO;
    self.dateCreated = 0L;
    self.blacklisted = NO;
  }
  return self;
}
static PasswordSpecificsData* defaultPasswordSpecificsDataInstance = nil;
+ (void) initialize {
  if (self == [PasswordSpecificsData class]) {
    defaultPasswordSpecificsDataInstance = [[PasswordSpecificsData alloc] init];
  }
}
+ (PasswordSpecificsData*) defaultInstance {
  return defaultPasswordSpecificsDataInstance;
}
- (PasswordSpecificsData*) defaultInstance {
  return defaultPasswordSpecificsDataInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasScheme) {
    [output writeInt32:1 value:self.scheme];
  }
  if (self.hasSignonRealm) {
    [output writeString:2 value:self.signonRealm];
  }
  if (self.hasOrigin) {
    [output writeString:3 value:self.origin];
  }
  if (self.hasAction) {
    [output writeString:4 value:self.action];
  }
  if (self.hasUsernameElement) {
    [output writeString:5 value:self.usernameElement];
  }
  if (self.hasUsernameValue) {
    [output writeString:6 value:self.usernameValue];
  }
  if (self.hasPasswordElement) {
    [output writeString:7 value:self.passwordElement];
  }
  if (self.hasPasswordValue) {
    [output writeString:8 value:self.passwordValue];
  }
  if (self.hasSslValid) {
    [output writeBool:9 value:self.sslValid];
  }
  if (self.hasPreferred) {
    [output writeBool:10 value:self.preferred];
  }
  if (self.hasDateCreated) {
    [output writeInt64:11 value:self.dateCreated];
  }
  if (self.hasBlacklisted) {
    [output writeBool:12 value:self.blacklisted];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasScheme) {
    size += computeInt32Size(1, self.scheme);
  }
  if (self.hasSignonRealm) {
    size += computeStringSize(2, self.signonRealm);
  }
  if (self.hasOrigin) {
    size += computeStringSize(3, self.origin);
  }
  if (self.hasAction) {
    size += computeStringSize(4, self.action);
  }
  if (self.hasUsernameElement) {
    size += computeStringSize(5, self.usernameElement);
  }
  if (self.hasUsernameValue) {
    size += computeStringSize(6, self.usernameValue);
  }
  if (self.hasPasswordElement) {
    size += computeStringSize(7, self.passwordElement);
  }
  if (self.hasPasswordValue) {
    size += computeStringSize(8, self.passwordValue);
  }
  if (self.hasSslValid) {
    size += computeBoolSize(9, self.sslValid);
  }
  if (self.hasPreferred) {
    size += computeBoolSize(10, self.preferred);
  }
  if (self.hasDateCreated) {
    size += computeInt64Size(11, self.dateCreated);
  }
  if (self.hasBlacklisted) {
    size += computeBoolSize(12, self.blacklisted);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (PasswordSpecificsData*) parseFromData:(NSData*) data {
  return (PasswordSpecificsData*)[[[PasswordSpecificsData builder] mergeFromData:data] build];
}
+ (PasswordSpecificsData*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PasswordSpecificsData*)[[[PasswordSpecificsData builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PasswordSpecificsData*) parseFromInputStream:(NSInputStream*) input {
  return (PasswordSpecificsData*)[[[PasswordSpecificsData builder] mergeFromInputStream:input] build];
}
+ (PasswordSpecificsData*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PasswordSpecificsData*)[[[PasswordSpecificsData builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PasswordSpecificsData*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PasswordSpecificsData*)[[[PasswordSpecificsData builder] mergeFromCodedInputStream:input] build];
}
+ (PasswordSpecificsData*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PasswordSpecificsData*)[[[PasswordSpecificsData builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PasswordSpecificsData_Builder*) builder {
  return [[[PasswordSpecificsData_Builder alloc] init] autorelease];
}
+ (PasswordSpecificsData_Builder*) builderWithPrototype:(PasswordSpecificsData*) prototype {
  return [[PasswordSpecificsData builder] mergeFrom:prototype];
}
- (PasswordSpecificsData_Builder*) builder {
  return [PasswordSpecificsData builder];
}
@end

@interface PasswordSpecificsData_Builder()
@property (retain) PasswordSpecificsData* result;
@end

@implementation PasswordSpecificsData_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[PasswordSpecificsData alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (PasswordSpecificsData_Builder*) clear {
  self.result = [[[PasswordSpecificsData alloc] init] autorelease];
  return self;
}
- (PasswordSpecificsData_Builder*) clone {
  return [PasswordSpecificsData builderWithPrototype:result];
}
- (PasswordSpecificsData*) defaultInstance {
  return [PasswordSpecificsData defaultInstance];
}
- (PasswordSpecificsData*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PasswordSpecificsData*) buildPartial {
  PasswordSpecificsData* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (PasswordSpecificsData_Builder*) mergeFrom:(PasswordSpecificsData*) other {
  if (other == [PasswordSpecificsData defaultInstance]) {
    return self;
  }
  if (other.hasScheme) {
    [self setScheme:other.scheme];
  }
  if (other.hasSignonRealm) {
    [self setSignonRealm:other.signonRealm];
  }
  if (other.hasOrigin) {
    [self setOrigin:other.origin];
  }
  if (other.hasAction) {
    [self setAction:other.action];
  }
  if (other.hasUsernameElement) {
    [self setUsernameElement:other.usernameElement];
  }
  if (other.hasUsernameValue) {
    [self setUsernameValue:other.usernameValue];
  }
  if (other.hasPasswordElement) {
    [self setPasswordElement:other.passwordElement];
  }
  if (other.hasPasswordValue) {
    [self setPasswordValue:other.passwordValue];
  }
  if (other.hasSslValid) {
    [self setSslValid:other.sslValid];
  }
  if (other.hasPreferred) {
    [self setPreferred:other.preferred];
  }
  if (other.hasDateCreated) {
    [self setDateCreated:other.dateCreated];
  }
  if (other.hasBlacklisted) {
    [self setBlacklisted:other.blacklisted];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PasswordSpecificsData_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PasswordSpecificsData_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 8: {
        [self setScheme:[input readInt32]];
        break;
      }
      case 18: {
        [self setSignonRealm:[input readString]];
        break;
      }
      case 26: {
        [self setOrigin:[input readString]];
        break;
      }
      case 34: {
        [self setAction:[input readString]];
        break;
      }
      case 42: {
        [self setUsernameElement:[input readString]];
        break;
      }
      case 50: {
        [self setUsernameValue:[input readString]];
        break;
      }
      case 58: {
        [self setPasswordElement:[input readString]];
        break;
      }
      case 66: {
        [self setPasswordValue:[input readString]];
        break;
      }
      case 72: {
        [self setSslValid:[input readBool]];
        break;
      }
      case 80: {
        [self setPreferred:[input readBool]];
        break;
      }
      case 88: {
        [self setDateCreated:[input readInt64]];
        break;
      }
      case 96: {
        [self setBlacklisted:[input readBool]];
        break;
      }
    }
  }
}
- (BOOL) hasScheme {
  return result.hasScheme;
}
- (int32_t) scheme {
  return result.scheme;
}
- (PasswordSpecificsData_Builder*) setScheme:(int32_t) value {
  result.hasScheme = YES;
  result.scheme = value;
  return self;
}
- (PasswordSpecificsData_Builder*) clearScheme {
  result.hasScheme = NO;
  result.scheme = 0;
  return self;
}
- (BOOL) hasSignonRealm {
  return result.hasSignonRealm;
}
- (NSString*) signonRealm {
  return result.signonRealm;
}
- (PasswordSpecificsData_Builder*) setSignonRealm:(NSString*) value {
  result.hasSignonRealm = YES;
  result.signonRealm = value;
  return self;
}
- (PasswordSpecificsData_Builder*) clearSignonRealm {
  result.hasSignonRealm = NO;
  result.signonRealm = @"";
  return self;
}
- (BOOL) hasOrigin {
  return result.hasOrigin;
}
- (NSString*) origin {
  return result.origin;
}
- (PasswordSpecificsData_Builder*) setOrigin:(NSString*) value {
  result.hasOrigin = YES;
  result.origin = value;
  return self;
}
- (PasswordSpecificsData_Builder*) clearOrigin {
  result.hasOrigin = NO;
  result.origin = @"";
  return self;
}
- (BOOL) hasAction {
  return result.hasAction;
}
- (NSString*) action {
  return result.action;
}
- (PasswordSpecificsData_Builder*) setAction:(NSString*) value {
  result.hasAction = YES;
  result.action = value;
  return self;
}
- (PasswordSpecificsData_Builder*) clearAction {
  result.hasAction = NO;
  result.action = @"";
  return self;
}
- (BOOL) hasUsernameElement {
  return result.hasUsernameElement;
}
- (NSString*) usernameElement {
  return result.usernameElement;
}
- (PasswordSpecificsData_Builder*) setUsernameElement:(NSString*) value {
  result.hasUsernameElement = YES;
  result.usernameElement = value;
  return self;
}
- (PasswordSpecificsData_Builder*) clearUsernameElement {
  result.hasUsernameElement = NO;
  result.usernameElement = @"";
  return self;
}
- (BOOL) hasUsernameValue {
  return result.hasUsernameValue;
}
- (NSString*) usernameValue {
  return result.usernameValue;
}
- (PasswordSpecificsData_Builder*) setUsernameValue:(NSString*) value {
  result.hasUsernameValue = YES;
  result.usernameValue = value;
  return self;
}
- (PasswordSpecificsData_Builder*) clearUsernameValue {
  result.hasUsernameValue = NO;
  result.usernameValue = @"";
  return self;
}
- (BOOL) hasPasswordElement {
  return result.hasPasswordElement;
}
- (NSString*) passwordElement {
  return result.passwordElement;
}
- (PasswordSpecificsData_Builder*) setPasswordElement:(NSString*) value {
  result.hasPasswordElement = YES;
  result.passwordElement = value;
  return self;
}
- (PasswordSpecificsData_Builder*) clearPasswordElement {
  result.hasPasswordElement = NO;
  result.passwordElement = @"";
  return self;
}
- (BOOL) hasPasswordValue {
  return result.hasPasswordValue;
}
- (NSString*) passwordValue {
  return result.passwordValue;
}
- (PasswordSpecificsData_Builder*) setPasswordValue:(NSString*) value {
  result.hasPasswordValue = YES;
  result.passwordValue = value;
  return self;
}
- (PasswordSpecificsData_Builder*) clearPasswordValue {
  result.hasPasswordValue = NO;
  result.passwordValue = @"";
  return self;
}
- (BOOL) hasSslValid {
  return result.hasSslValid;
}
- (BOOL) sslValid {
  return result.sslValid;
}
- (PasswordSpecificsData_Builder*) setSslValid:(BOOL) value {
  result.hasSslValid = YES;
  result.sslValid = value;
  return self;
}
- (PasswordSpecificsData_Builder*) clearSslValid {
  result.hasSslValid = NO;
  result.sslValid = NO;
  return self;
}
- (BOOL) hasPreferred {
  return result.hasPreferred;
}
- (BOOL) preferred {
  return result.preferred;
}
- (PasswordSpecificsData_Builder*) setPreferred:(BOOL) value {
  result.hasPreferred = YES;
  result.preferred = value;
  return self;
}
- (PasswordSpecificsData_Builder*) clearPreferred {
  result.hasPreferred = NO;
  result.preferred = NO;
  return self;
}
- (BOOL) hasDateCreated {
  return result.hasDateCreated;
}
- (int64_t) dateCreated {
  return result.dateCreated;
}
- (PasswordSpecificsData_Builder*) setDateCreated:(int64_t) value {
  result.hasDateCreated = YES;
  result.dateCreated = value;
  return self;
}
- (PasswordSpecificsData_Builder*) clearDateCreated {
  result.hasDateCreated = NO;
  result.dateCreated = 0L;
  return self;
}
- (BOOL) hasBlacklisted {
  return result.hasBlacklisted;
}
- (BOOL) blacklisted {
  return result.blacklisted;
}
- (PasswordSpecificsData_Builder*) setBlacklisted:(BOOL) value {
  result.hasBlacklisted = YES;
  result.blacklisted = value;
  return self;
}
- (PasswordSpecificsData_Builder*) clearBlacklisted {
  result.hasBlacklisted = NO;
  result.blacklisted = NO;
  return self;
}
@end

@interface PasswordSpecifics ()
@property (retain) EncryptedData* encrypted;
@end

@implementation PasswordSpecifics

- (BOOL) hasEncrypted {
  return !!hasEncrypted_;
}
- (void) setHasEncrypted:(BOOL) value {
  hasEncrypted_ = !!value;
}
@synthesize encrypted;
- (void) dealloc {
  self.encrypted = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.encrypted = [EncryptedData defaultInstance];
  }
  return self;
}
static PasswordSpecifics* defaultPasswordSpecificsInstance = nil;
+ (void) initialize {
  if (self == [PasswordSpecifics class]) {
    defaultPasswordSpecificsInstance = [[PasswordSpecifics alloc] init];
  }
}
+ (PasswordSpecifics*) defaultInstance {
  return defaultPasswordSpecificsInstance;
}
- (PasswordSpecifics*) defaultInstance {
  return defaultPasswordSpecificsInstance;
}
- (BOOL) isInitialized {
  return YES;
}
- (void) writeToCodedOutputStream:(PBCodedOutputStream*) output {
  if (self.hasEncrypted) {
    [output writeMessage:1 value:self.encrypted];
  }
  [self.unknownFields writeToCodedOutputStream:output];
}
- (int32_t) serializedSize {
  int32_t size = memoizedSerializedSize;
  if (size != -1) {
    return size;
  }

  size = 0;
  if (self.hasEncrypted) {
    size += computeMessageSize(1, self.encrypted);
  }
  size += self.unknownFields.serializedSize;
  memoizedSerializedSize = size;
  return size;
}
+ (PasswordSpecifics*) parseFromData:(NSData*) data {
  return (PasswordSpecifics*)[[[PasswordSpecifics builder] mergeFromData:data] build];
}
+ (PasswordSpecifics*) parseFromData:(NSData*) data extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PasswordSpecifics*)[[[PasswordSpecifics builder] mergeFromData:data extensionRegistry:extensionRegistry] build];
}
+ (PasswordSpecifics*) parseFromInputStream:(NSInputStream*) input {
  return (PasswordSpecifics*)[[[PasswordSpecifics builder] mergeFromInputStream:input] build];
}
+ (PasswordSpecifics*) parseFromInputStream:(NSInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PasswordSpecifics*)[[[PasswordSpecifics builder] mergeFromInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PasswordSpecifics*) parseFromCodedInputStream:(PBCodedInputStream*) input {
  return (PasswordSpecifics*)[[[PasswordSpecifics builder] mergeFromCodedInputStream:input] build];
}
+ (PasswordSpecifics*) parseFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  return (PasswordSpecifics*)[[[PasswordSpecifics builder] mergeFromCodedInputStream:input extensionRegistry:extensionRegistry] build];
}
+ (PasswordSpecifics_Builder*) builder {
  return [[[PasswordSpecifics_Builder alloc] init] autorelease];
}
+ (PasswordSpecifics_Builder*) builderWithPrototype:(PasswordSpecifics*) prototype {
  return [[PasswordSpecifics builder] mergeFrom:prototype];
}
- (PasswordSpecifics_Builder*) builder {
  return [PasswordSpecifics builder];
}
@end

@interface PasswordSpecifics_Builder()
@property (retain) PasswordSpecifics* result;
@end

@implementation PasswordSpecifics_Builder
@synthesize result;
- (void) dealloc {
  self.result = nil;
  [super dealloc];
}
- (id) init {
  if ((self = [super init])) {
    self.result = [[[PasswordSpecifics alloc] init] autorelease];
  }
  return self;
}
- (PBGeneratedMessage*) internalGetResult {
  return result;
}
- (PasswordSpecifics_Builder*) clear {
  self.result = [[[PasswordSpecifics alloc] init] autorelease];
  return self;
}
- (PasswordSpecifics_Builder*) clone {
  return [PasswordSpecifics builderWithPrototype:result];
}
- (PasswordSpecifics*) defaultInstance {
  return [PasswordSpecifics defaultInstance];
}
- (PasswordSpecifics*) build {
  [self checkInitialized];
  return [self buildPartial];
}
- (PasswordSpecifics*) buildPartial {
  PasswordSpecifics* returnMe = [[result retain] autorelease];
  self.result = nil;
  return returnMe;
}
- (PasswordSpecifics_Builder*) mergeFrom:(PasswordSpecifics*) other {
  if (other == [PasswordSpecifics defaultInstance]) {
    return self;
  }
  if (other.hasEncrypted) {
    [self mergeEncrypted:other.encrypted];
  }
  [self mergeUnknownFields:other.unknownFields];
  return self;
}
- (PasswordSpecifics_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input {
  return [self mergeFromCodedInputStream:input extensionRegistry:[PBExtensionRegistry emptyRegistry]];
}
- (PasswordSpecifics_Builder*) mergeFromCodedInputStream:(PBCodedInputStream*) input extensionRegistry:(PBExtensionRegistry*) extensionRegistry {
  PBUnknownFieldSet_Builder* unknownFields = [PBUnknownFieldSet builderWithUnknownFields:self.unknownFields];
  while (YES) {
    int32_t tag = [input readTag];
    switch (tag) {
      case 0:
        [self setUnknownFields:[unknownFields build]];
        return self;
      default: {
        if (![self parseUnknownField:input unknownFields:unknownFields extensionRegistry:extensionRegistry tag:tag]) {
          [self setUnknownFields:[unknownFields build]];
          return self;
        }
        break;
      }
      case 10: {
        EncryptedData_Builder* subBuilder = [EncryptedData builder];
        if (self.hasEncrypted) {
          [subBuilder mergeFrom:self.encrypted];
        }
        [input readMessage:subBuilder extensionRegistry:extensionRegistry];
        [self setEncrypted:[subBuilder buildPartial]];
        break;
      }
    }
  }
}
- (BOOL) hasEncrypted {
  return result.hasEncrypted;
}
- (EncryptedData*) encrypted {
  return result.encrypted;
}
- (PasswordSpecifics_Builder*) setEncrypted:(EncryptedData*) value {
  result.hasEncrypted = YES;
  result.encrypted = value;
  return self;
}
- (PasswordSpecifics_Builder*) setEncryptedBuilder:(EncryptedData_Builder*) builderForValue {
  return [self setEncrypted:[builderForValue build]];
}
- (PasswordSpecifics_Builder*) mergeEncrypted:(EncryptedData*) value {
  if (result.hasEncrypted &&
      result.encrypted != [EncryptedData defaultInstance]) {
    result.encrypted =
      [[[EncryptedData builderWithPrototype:result.encrypted] mergeFrom:value] buildPartial];
  } else {
    result.encrypted = value;
  }
  result.hasEncrypted = YES;
  return self;
}
- (PasswordSpecifics_Builder*) clearEncrypted {
  result.hasEncrypted = NO;
  result.encrypted = [EncryptedData defaultInstance];
  return self;
}
@end

